多機能スケジュール管理アプリ 仕様書 
1. アプリケーション概要
名称 (仮称): スクールタスクプランナー (School Task Planner)
目的: 学生が学校の課題やテストなどのスケジュールを効率的に管理し、日々の学習計画を立てやすくすることを支援するWebアプリケーション。
ターゲットユーザー: 学生 (中学生、高校生、大学生など)
主な特徴:
カレンダーでの予定・課題表示
課題の詳細管理 (締切、科目、進捗など)
課題情報が書かれた写真からOCRで情報を読み取り、自動入力支援
AIによる「今日やるべきタスク」の推奨
ユーザー認証によるプライベートな利用
2. プラットフォーム
種別: Webアプリケーション
アクセス: PC、スマートフォン、タブレット等のWebブラウザからアクセス可能
3. 主要機能詳細
3.1. ユーザー認証機能
サインアップ:
入力項目: メールアドレス、パスワード、パスワード確認
機能: 新規ユーザーアカウントを作成する。パスワードはハッシュ化してデータベースに保存する。
ログイン:
入力項目: メールアドレス、パスワード
機能: 登録済みユーザーが認証を行い、アプリケーションにアクセスできるようにする。セッション管理を行う。
ログアウト:
機能: 現在のセッションを終了し、ログイン画面に戻る。
3.2. カレンダー表示機能
表示形式: 月表示をデフォルトとし、週表示、日表示に切り替え可能にする。
イベント表示: 登録された課題の締切日や、別途登録したイベント（テスト、学校行事など）をカレンダー上に表示する。
操作:
日付をクリックすると、その日の課題・イベント一覧を表示する。
日付をクリックした際に、新規の課題やイベントを登録するボタンを表示する。
ライブラリ候補: FullCalendar.js の利用を推奨（必須ではないが、実装の効率が良い可能性あり）。
3.3. 課題管理機能 (CRUD)
課題登録 (Create):
入力項目:
課題名 (必須)
科目 (必須、選択式または自由入力)
締切日時 (必須、日付と時刻)
内容・メモ (任意、テキストエリア)
重要度 (必須、選択式: 高・中・低)
進捗状況 (必須、選択式: 未着手・進行中・完了、デフォルトは「未着手」)
想定所要時間 (任意、時間単位で入力)
機能: 新しい課題をデータベースに登録する。
課題一覧表示 (Read):
機能: 登録されている課題を一覧で表示する。
表示項目: 課題名、科目、締切日時、重要度、進捗状況
ソート機能: 締切日時順（昇順/降順）、重要度順などで並び替え可能にする。
フィルタリング機能: 科目別、進捗状況別などで絞り込み表示可能にする。
課題詳細表示 (Read):
機能: 一覧から課題を選択すると、登録されている全ての情報（内容メモ、想定所要時間含む）を表示する。
課題更新 (Update):
機能: 既存の課題情報を編集・更新できるようにする。
課題削除 (Delete):
機能: 既存の課題を削除できるようにする（確認メッセージを表示）。
3.4. 画像OCRによる課題自動登録支援機能
インターフェース: 課題登録フォーム内、または専用のボタンから画像アップロード機能を提供する。
画像形式: JPEG, PNG形式に対応する。
処理フロー:
ユーザーが課題情報（締切日、課題名など）が書かれた写真をアップロードする。
アップロードされた画像を Google Gemini API (Vision対応モデル、例: gemini-1.5-pro-latest または gemini-1.5-flash-latest) に送信する。
Gemini APIへのプロンプト (例):
あなたは学校の課題情報を抽出するエキスパートです。
この画像から以下の情報を抽出してください:
- 課題名
- 科目名
- 締切日 (YYYY-MM-DD 形式で)
- 締切時刻 (HH:MM 形式で、もしあれば)

抽出結果をJSON形式で返してください。例:
{
  "課題名": "〇〇レポート",
  "科目名": "現代文",
  "締切日": "2024-08-15",
  "締切時刻": "17:00"
}
もし情報が見つからない場合は、該当する項目をnullにしてください。
Use code with caution.
Text
APIからの応答 (JSON形式) を解析する。
解析結果を、新規課題登録フォームの対応するフィールドに自動入力する。
ユーザーは自動入力された内容を確認し、必要に応じて修正してから課題を登録する。
エラーハンドリング:
API呼び出しに失敗した場合、ユーザーにエラーメッセージを表示する。
画像から情報がうまく抽出できなかった場合、その旨をユーザーに伝え、手動入力を促す。
APIキー管理: Gemini APIキーはソースコードに直接記述せず、環境変数など安全な方法で管理する。
3.5. AIによるタスク推奨機能
インターフェース: ダッシュボード画面や専用の「今日のタスク」セクションに表示する。表示タイミングは、ログイン時か、ユーザーが「推奨を表示」ボタンをクリックした時かを選べるようにする。
確認: 表示タイミングはどちらがよろしいでしょうか？ (1) ログイン時に自動表示、(2) ボタンクリック時
処理フロー:
データベースから「未着手」または「進行中」の課題リストを取得する。
各課題の情報（課題名、科目、締切日時、残り日数、重要度、想定所要時間など）を整理し、テキスト形式のリストを作成する。
整理した課題リストのテキストを Google Gemini API (Textモデル、例: gemini-1.5-pro-latest または gemini-1.5-flash-latest) に送信する。
Gemini APIへのプロンプト (例):
あなたは優秀な学習プランナーです。
以下の課題リストと現在の日付 ({現在の日付}) を考慮して、今日最も優先して取り組むべきタスクを3つ提案してください。
各タスクについて、優先すべき理由も簡潔に説明してください。

課題リスト:
- {課題名1}, 科目: {科目1}, 締切: {締切日時1}, 重要度: {重要度1}, 残り日数: {残り日数1}, 想定時間: {時間1}
- {課題名2}, 科目: {科目2}, 締切: {締切日時2}, 重要度: {重要度2}, 残り日数: {残り日数2}, 想定時間: {時間2}
...

出力形式:
1. {推奨課題名1} (理由: {理由1})
2. {推奨課題名2} (理由: {理由2})
3. {推奨課題名3} (理由: {理由3})
Use code with caution.
Text
APIからの応答（推奨タスクと理由のテキスト）を解析し、ユーザーに分かりやすく表示する。
エラーハンドリング: API呼び出しに失敗した場合、ユーザーにエラーメッセージを表示する。
APIキー管理: Gemini APIキーはソースコードに直接記述せず、環境変数など安全な方法で管理する。
4. 使用技術 (推奨)
フロントエンド: HTML, CSS, JavaScript
確認: 特定のJavaScriptフレームワーク (React, Vue.js, Angularなど) を使用したいですか？ それともOpenDevinに選択を任せますか？ (指定なしの場合、シンプルなJavaScriptまたはOpenDevinが得意なものが選ばれる可能性があります)
バックエンド: Python
確認: Webフレームワークとして Django または Flask のどちらを推奨しますか？ (指定がなければOpenDevinが選ぶか、より一般的なFlaskが選ばれるかもしれません)
データベース:
確認: 開発初期段階ではSQLiteを使用し、将来的（デプロイ時など）にPostgreSQLなどへの移行を考慮する、という方針でよろしいでしょうか？
AI/OCR: Google Gemini API (Google AI Studio経由でAPIキー取得)
注意: 無料枠の制限 (RPM, TPM, RPD) を考慮し、特に画像アップロード機能の利用頻度が高くなりすぎないように設計・利用する必要がある。API呼び出し回数を節約する工夫（例: 一定時間はキャッシュを使うなど）も検討の余地あり。
その他ライブラリ:
カレンダー: FullCalendar.js (推奨)
日付処理: Pythonのdatetimeモジュールなど
5. UI/UX
デザイン: クリーンでシンプル、直感的に操作できるデザインを目指す。
レスポンシブ: PC、タブレット、スマートフォンの各画面サイズで適切に表示・操作できるようにする。
フィードバック: 操作の成功時（保存完了など）、エラー発生時にはユーザーに明確なメッセージを表示する。
6. その他
セキュリティ:
パスワードのハッシュ化 (済)
SQLインジェクション対策 (ORMを使用する場合は基本的な対策はされることが多い)
クロスサイトスクリプティング (XSS) 対策 (テンプレートエンジン等で適切にエスケープ処理を行う)
入力値の検証 (不正なデータが登録されないようにする)
拡張性: 将来的に機能追加（例: 定期テストの管理、リマインダー機能など）がしやすいような設計を心がける。

~実装手順~

多機能スケジュール管理アプリ 実装手順案 (OpenDevin向け)
フェーズ 1: 基盤構築とコア機能の実装
ステップ 1: プロジェクトセットアップと基本構成
指示: Python Flaskプロジェクトの基本的なディレクトリ構造を作成してください。
app.py (メインのFlaskアプリケーションファイル)
templates/ (HTMLテンプレート用ディレクトリ)
static/ (CSS, JavaScript, 画像ファイル用ディレクトリ)
requirements.txt (依存ライブラリ管理ファイル)
.gitignore ファイル (Git管理対象外ファイル指定)
指示: requirements.txt に Flask と Flask-SQLAlchemy (データベースORM用) を追加し、仮想環境を作成してインストールしてください。
指示: SQLiteデータベースを設定し、app.py で Flask-SQLAlchemy を初期化してください。データベースファイル名は database.db とします。
ステップ 2: ユーザー認証機能の実装
指示: ユーザー情報を格納するための User モデルを定義してください (Flask-SQLAlchemyを使用)。
フィールド: id (主キー), email (ユニーク、必須), password_hash (必須)
指示: パスワードを安全にハッシュ化するためのライブラリ (例: werkzeug.security) を使用してください。
指示: 以下のルートと対応するHTMLテンプレート (templates/内) を作成してください。
/signup (GET, POST): 新規ユーザー登録フォーム表示と処理。成功したらログインページへリダイレクト。
/login (GET, POST): ログインフォーム表示と処理。認証成功後はセッションを開始し、メインページへリダイレクト。
/logout (GET): セッションを終了し、ログインページへリダイレクト。
指示: ログインが必要なページへのアクセス制御を実装してください (例: @login_required デコレータ)。
ステップ 3: 課題管理機能 (CRUD) の実装
指示: 課題情報を格納するための Task モデルを定義してください (Flask-SQLAlchemyを使用)。
フィールド: id (主キー), user_id (外部キー, Userモデルと連携), title (必須), subject, due_date (日時型), details, priority (高/中/低), status (未着手/進行中/完了), estimated_time
指示: 以下のルートと対応するHTMLテンプレートを作成してください。
/tasks (GET): ログイン中のユーザーの課題一覧を表示するページ。
/tasks/new (GET, POST): 新規課題登録フォーム表示と処理。登録後は課題一覧ページへリダイレクト。
/tasks/<int:task_id> (GET): 特定の課題の詳細を表示するページ。
/tasks/<int:task_id>/edit (GET, POST): 課題編集フォーム表示と処理。更新後は課題詳細ページまたは一覧ページへリダイレクト。
/tasks/<int:task_id>/delete (POST): 課題を削除する処理。削除後は課題一覧ページへリダイレクト（確認処理をJSで追加）。
指示: 課題一覧ページに、締切日や重要度でのソート機能、科目やステータスでのフィルタリング機能を追加してください（バックエンドで処理）。
ステップ 4: 基本的なカレンダー表示機能の実装
指示: カレンダー表示用のルート (/calendar など) とHTMLテンプレートを作成してください。
指示: フロントエンドで FullCalendar.js を読み込み、初期化してください。
指示: バックエンドでログイン中のユーザーの課題を取得し、FullCalendarが要求する形式 (JSON) でイベントデータを提供するAPIエンドポイント (/api/events など) を作成してください。
指示: FullCalendar が /api/events からデータを取得し、カレンダー上に課題の締切を表示するように設定してください。
指示: カレンダーの日付をクリックした際に、新規課題登録ページへのリンクを表示するようにしてください。
(この時点で、基本的なログイン、課題管理、カレンダー表示ができる状態を目指します)
フェーズ 2: AI連携機能の実装
ステップ 5: 画像OCRによる課題自動登録支援機能の実装
指示: google-generativeai ライブラリを requirements.txt に追加し、インストールしてください。
指示: Gemini APIキーを環境変数 (GEMINI_API_KEY) から読み込むように設定してください。APIキーをコードに直接書かないでください。
指示: 課題登録フォーム (/tasks/new) または専用ページに、画像アップロード用の <input type="file"> を追加してください。
指示: 画像がアップロードされた際に、バックエンドで受け取るルート (例: /api/ocr_task) を作成してください。
指示: 受け取った画像データを Gemini API (Visionモデル: gemini-1.5-flash-latest) に送信し、仕様書にあるプロンプト例を参考に課題情報を抽出する処理を実装してください。
指示: Gemini APIからの応答 (JSON) を解析し、その結果をフロントエンドに返却してください。
指示: フロントエンドのJavaScriptで、APIからの結果を受け取り、課題登録フォームの該当フィールド（課題名、科目、締切日など）に自動入力してください。
指示: APIエラー発生時のハンドリングと、ユーザーへのメッセージ表示を実装してください。
ステップ 6: AIによるタスク推奨機能の実装
指示: ダッシュボードや課題一覧ページなどに「今日の推奨タスクを表示」ボタンを追加してください。
指示: ボタンクリック時にバックエンドのAPIエンドポイント (例: /api/recommend_tasks) を呼び出すJavaScriptを実装してください。
指示: /api/recommend_tasks ルートで、ログイン中のユーザーの未完了タスクを取得し、仕様書にあるプロンプト例のようにテキスト情報を整理してください。
指示: 整理したタスク情報を Gemini API (Textモデル: gemini-1.5-flash-latest) に送信し、推奨タスクとその理由を取得する処理を実装してください (APIキーは環境変数から)。
指示: Gemini APIからの応答を解析し、整形してフロントエンドに返却してください。
指示: フロントエンドでAPIからの推奨タスク情報を受け取り、画面上の指定された領域に表示してください。
指示: APIエラー発生時のハンドリングと、ユーザーへのメッセージ表示を実装してください。
フェーズ 3: 仕上げと改善
ステップ 7: UI/UXの改善
指示: アプリケーション全体のCSSを調整し、クリーンで一貫性のあるデザインにしてください。
指示: 各ページのレイアウトが、スマートフォンやタブレットでも適切に表示されるようにレスポンシブ対応を行ってください (CSSメディアクエリなどを使用)。
指示: フォームの入力検証 (必須項目チェック、日付形式など) をフロントエンド (JavaScript) とバックエンド (Flask) の両方で実装してください。
指示: 操作完了時 (保存、削除など) のフィードバックメッセージ (例: "課題を登録しました") を表示するようにしてください。
ステップ 8: テストとデバッグ
指示: 各機能（ユーザー登録、ログイン、課題CRUD、OCR、AI推奨、カレンダー表示）が仕様通りに動作するか、手動でテストしてください。
指示: 予期せぬ入力や操作に対するエラーハンドリングが適切に行われているか確認してください。
指示: ブラウザの開発者ツールで、コンソールエラーやネットワークエラーが発生していないか確認してください。
指示: (可能であれば) 主要な機能に対する自動テスト (ユニットテスト、結合テスト) を記述してください (例: pytest)。




